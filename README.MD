# DOCS

## Feature Sliced Design (FSD)

- [official docs](https://feature-sliced.design/docs)

### Доклады

- про FSD [Feature-Sliced Design / Александр Моргунов](https://youtu.be/M84x3pzDYr0)
- FSD на примере MVP проектов (3-6 месяцев) на практике [Эволюция архитектуры. Как мы пришли к FSD / Сергей Пономарёв, Purrweb](https://youtu.be/KVcY1bfUCBU)
- docs

### Examples

#### Official react examples

- [nukeapp](https://github.com/noveogroup-amorgunov/nukeapp)
- [realworld-react-fsd](https://github.com/yurisldk/realworld-react-fsd)

#### FSD MWWM MOBX example

- [fsd_mwwm_mobx_demo](https://github.com/altynbek132/fsd_mwwm_mobx_demo)

### Community

- [tg community](https://t.me/feature_sliced)
- [use as community discussions reference bot, do not rely on his answers](https://t.me/feature_sliced/92691)

### Введение

После анализа различных докладов становится очевидным, что команды разработки часто приходят к организации кодовой базы по фичам. Традиционная Чистая Архитектура предусматривает разделение только по слоям, чего не всегда достаточно для поддержания чистой кодовой базы с низкой связанностью. Поэтому вводится вертикальное разделение по фичам, где слои представляют горизонтальные срезы из Чистой Архитектуры, а фичи - вертикальные.

### Соответствие слоев c чистой Архитектурой

![диаграмма](https://github.com/altynbek132/arbihunter_docs/blob/main/clean_fsd.png)

- "Domain" → "Entities"
- "Application" → "Features"

#### Различие

![диаграмма](https://github.com/altynbek132/arbihunter_docs/blob/main/clean_fsd_ui.png)

- UI выделяется как отдельный слой во внешнем слое

### Основные преимущества

- UI распределен по слоям (что удобно, так как UI-элементы часто связаны с сущностями, фичами или виджетами)
- Четкое разделение по фичам и слоям
- Строгий порядок импортов (верхние слои могут импортировать из нижних, но не наоборот)
- Слайсовая организация каждого слоя

### Ключевые пояснения

#### Слой Features

- Переиспользуемая бизнес-логика

#### Слайсы

- Группы связанных модулей
- Высокая связность внутри
- Отсутствие кросс-импортов

### Предлагаемые дополнения

1. Опциональные под-слайсы
2. Гибкие правила кросс-импортов для виджетов
3. Применение паттернов в подслое фич с агрегацией фич

### Рекомендации по разработке

1. Начало с:
   - pages
   - shared компонентов
2. Размещение логики:
   - Изначально в слое pages в widget_model рядом с экраном
   - Вынос в отдельные сущности/слайсы при переиспользовании 3+ раз

### Заключение

Такой подход обеспечивает лучшую организацию, сохраняя при этом гибкость и масштабируемость.

---

Если вы хотите задавать вопросы по определенной документации (например, FSD) и получать ответы с референсами, вы можете:

Скачать весь репозиторий с документацией

Загрузить файлы в формате Markdown в:

- Gemini
- или Claude (если хватает размера контекстного окна)

После этого AI сможет отвечать на ваши вопросы, опираясь на загруженную документацию и предоставлять соответствующие ссылки на источники.

[пример](https://github.com/altynbek132/arbihunter_docs/blob/main/msty_example.png)

## MOBX + STREAM

- [official docs](https://mobx.netlify.app/)

Я решил полностью отказаться от кодогенерации при работе с MobX по двум причинам.

- сам процесс кодогенерации может быть проблематичным.
- сгенерированный код часто сложен для понимания.

Использование MobX напрямую, без кодогенерации, делает код более прозрачным и понятным - легче отследить, как и что работает.

- [mobx_utils.dart](https://github.com/altynbek132/flutter_util_packages/blob/main/packages/utils/lib/utils_dart/mobx_utils.dart)
  - MobXUtilsDart - это вспомогательный класс, который предоставляет утилиты для конвертации MobX Observable объектов в Stream-ы, а также для их создания.
- [mobx_utils.dart](https://github.com/altynbek132/flutter_util_packages/blob/main/packages/utils/lib/utils_flutter/mobx_utils.dart)
  - MobXUtils содержит методы для преобразования Listenable объектов из Flutter в Observable, поскольку по умолчанию Listenable, который отправляет уведомления об изменениях, не вызывает реакции MobX.
- [mobx_store_base.dart](https://github.com/altynbek132/flutter_util_packages/blob/main/packages/utils/lib/utils_flutter/mobx_store_base.dart)
  - Этот абстрактный класс служит основой для создания виджет-модуля, интегрированного с MobX. В нём реализованы асинхронный и синхронный методы dispose, а также механизм логирования. Класс дополнен миксином disposable bag, позволяющим использовать весь виджет-модуль в качестве disposable bag и присоединять к нему различные disposables-объекты.

## ELEMENTARY

- [official docs](https://pub.dev/packages/elementary)
- [vscode mwwm+mobx generator](https://marketplace.visualstudio.com/items?itemName=altynbek132.mobx-elementary-generator)
  - здесь нужно правой кнопкой мыши нажать на папку и выбрать пункт "Generate" (или "Сгенерировать")
- [Elementary — MVVM для Flutter под новым углом / Михаил Зотьев (Surf)](https://www.youtube.com/watch?v=pehjIuuvPUQ)

Давайте разберем суть Elementary и его роль в разработке:

Elementary решает важную архитектурную задачу - разделение пользовательского интерфейса (UI) от логики UI и бизнес-логики. Это классическая реализация паттерна MVVM (Model-View-ViewModel).

Я создал модифицированную версию ([форк](https://github.com/altynbek132/flutter-elementary)) Elementary, которая делает разделение бизнес-логики опциональным. Это позволяет:

- Ускорить процесс разработки
- При необходимости объединять в widget-model как UI логику, так и бизнес-логику
- Идти на компромисс между скоростью разработки и техническим долгом

Важно отметить, что концепция ViewModel, используемая в Elementary, берет свое начало из Android-разработки. В обеих платформах ViewModel выполняет схожие функции:

- Управление состоянием UI
- Обработка взаимодействия с бизнес-логикой
- Координация между представлением и данными

Таким образом, и Android ViewModel, и widget-model в Elementary концептуально очень близки, так как решают одни и те же архитектурные задачи.

## SYNCHRONIZED

- [official docs](https://pub.dev/packages/synchronized)

### Решение проблемы Race Condition с помощью пакета Synchronizer

#### Проблема

В UI-системах существует проблема race condition при обработке событий. Поскольку все выполняется в Event Loop, пользователь может:

- Одновременно нажать несколько кнопок
- Быстро нажать одну кнопку несколько раз

#### Два основных подхода решения

##### 1. Использование Streams с AsyncMap

- События обрабатываются через AsyncMap
- Следующее событие не начнет обрабатываться до завершения текущего
- Обработка происходит последовательно

##### 2. Использование пакета Synchronizer с locks

- Создается mutex-подобный механизм
- Вызывается метод synchronize с асинхронной функцией в качестве аргумента
- Lock гарантирует, что новая асинхронная функция не запустится до завершения предыдущей
- Обеспечивает последовательное выполнение операций

Оба метода помогают избежать конфликтов при параллельной обработке событий, обеспечивая их упорядоченное выполнение.

### SYNCHRONIZED+MOBX

- [observable_lock](https://github.com/altynbek132/flutter_util_packages/blob/main/packages/utils/lib/utils_dart/observable_lock.dart)
  - Я реализовал обёртку над механизмом блокировки, обеспечивающую реактивное отслеживание состояния через MobX.

## LLM

### Conentional commits

- [android studio plugin](https://plugins.jetbrains.com/plugin/21335-ai-commits), [prompt with arbihunter guidelines](https://github.com/altynbek132/arbihunter_docs/blob/main/ai_commit_prompt_AS.txt)
- [vscode plugin](https://marketplace.visualstudio.com/items?itemName=Sitoi.ai-commit), [prompt without arbihunter guidelines](https://github.com/altynbek132/arbihunter_docs/blob/main/ai_commit_prompt_vscode.txt)

Сгенерировать commit message очень просто: вставляете этот промпт в настройки расширения, выбираете изменения для commit (добавляете в staging area), запускаете генератор, и он автоматически создаст сообщение commit.

Также, если вы хотите разбить большие commit на более мелкие или работать с несколькими списками изменений ("changelists"), чтобы разделять, например, локальные изменения от относящихся к задаче, рекомендую использовать систему commit Android Studio. Там можно создать несколько changelists, например, для локальных изменений, типа глобальных настроек или UI, чтобы случайно их не закоммитить. Кроме того, Android Studio позволяет выбирать конкретные строки для включения в commit, что полезно, когда нужно максимально точно раздробить изменения

### api ui wrapper

[msty](https://msty.app/)

Я настоятельно рекомендую скачать эту программу. Я искал удобные обертки для ChatGPT, сравнивал разные варианты, и эта выделяется своей функциональностью. Особенно мне нравится организация по папкам и возможность задать системный промпт для каждой папки. Это значит, что любой новый чат, созданный внутри папки, автоматически унаследует заданный системный промпт. Например, можно создать папку для "советчика по дизайн-паттернам", предварительно настроенную с соответствующим промптом.

Еще одно ключевое отличие от стандартного интерфейса ChatGPT заключается в том, как программа обрабатывает прикрепленные файлы с референсами. Вместо использования системы Retrieval-Augmented Generation (RAG) — которая создает базу данных фрагментов вашего материала и запрашивает у нее релевантную информацию — эта программа загружает файлы непосредственно в контекстное окно в виде полного текста. Это более эффективно, потому что системы RAG часто не могут проанализировать все релевантные фрагменты данных вместе, что потенциально упускает важный контекст. Вы можете прочитать больше о RAG, чтобы лучше понять разницу.

Кроме того, в это приложение встроена функция преобразования текста в речь, использующая технологию Whisper от ChatGPT. Здесь также есть отличные функции ветвления чатов, позволяющие повторно использовать промпты. Например, можно отправить коллекцию файлов в качестве референсов (например, для Feature-Sliced Design или FSD), задать вопросы, а затем создать новую ветку с этого места, чтобы продолжить изучение. Но организация по папкам с отдельными промптами и загрузка референсов в полном контексте — это самые крутые функции, которых я не нашел в других обертках для ChatGPT.

### providers

Для несложных задач, таких как формирование названий коммитов, оптимально использовать LLM-провайдера **gpt-4o[-mini]**, поскольку он экономически выгоден. Для более сложных задач стоит рассмотреть **Gemini**, учитывая его контекстное окно. У Gemini впечатляющее контекстное окно в один миллион токенов, что является уникальным преимуществом, однако его выходное окно ограничено 16 тысячами токенов. Тем не менее, большой контекст ввода позволяет поддерживать продолжительные диалоги.

Оба этих провайдера (gpt-4o[-mini] и Gemini) могут служить в качестве советчиков или предоставлять ссылки на релевантную информацию. Их можно использовать для абстрагирования вопросов и расширенного исследования темы, а также для получения референсов по смежным областям. К примеру у вас есть задача по Front-End разработки, вы можете узнать, как аналогичная проблема решается в Back-End или в других отраслях разработки.

Для задач средней сложности, таких как верстка или разработка более сложной логики, рекомендуется использовать **Claude 3.5 Sonnet** (обновленную версию) или **DeepSeek R1** через OpenRouter. Важно отметить, что DeepSeek R1 доступен только через OpenRouter, и при использовании других провайдеров может наблюдаться низкая пропускная способность. На данный момент лучшим выбором для такого рода задач является **Claude 3.5 Sonnet**.

## FORKS

### mobx.dart

#### Новые возможности

- Добавлены прокси-конструкторы для коллекций:
  - ObservableMap
  - ObservableList
  - ObservableSet
- Добавлен новый метод `reportManualChange` в класс Observable для ручного отслеживания изменений

#### Рефакторинг

- Переименована переменная `context` в `reactiveContext` в сгенерированном коде для большей ясности
- Обновлен Store mixin для использования `reactiveContext` вместо `context` для единообразия

- awesome_extensions

разделение импортов на дарт и флаттер части

- dart_disposing

разделение импортов на дарт и флаттер части

- flutter-elementary

делает разделение бизнес-логики опциональным

- lint_rules

debug lint rules
